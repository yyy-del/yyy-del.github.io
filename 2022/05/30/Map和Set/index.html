
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Map和Set | Blog</title>
        <meta name="author" content="yangtao">
        <meta name="description" content="">
        <meta name="keywords" content="">
        <link rel="icon" href="https://pic.cnblogs.com/face/2830946/20220406131847.png">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Blog</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Blog</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        
<div class="article">
    <div>
        <h1>Map和Set </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/5/30
        </span>
        
        <span class="category">
            <a href="/categories/前端/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                前端
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
            </span>
            
            <span class="tag">
                
                <a href="/tags/js-ES6/" style="color: #00a596">
                    js ES6
                </a>
            </span>
            
        </span>
        
    </div>
    <div class="content" v-pre>
        <h3 id="最近在项目中用到了Set，顺便复习了一下Set的基本API，因为Map和Set很多地方是相通的，所以顺便把Map也带上，本文只介绍基本API，这两个对象在我在项目中用的很少，至于用它们实现私有方法和存储DOM的引用推荐去看阮一峰的ES6入门，这里推荐一个大佬博客-这篇文章讲WeakMap讲的很好。"><a href="#最近在项目中用到了Set，顺便复习了一下Set的基本API，因为Map和Set很多地方是相通的，所以顺便把Map也带上，本文只介绍基本API，这两个对象在我在项目中用的很少，至于用它们实现私有方法和存储DOM的引用推荐去看阮一峰的ES6入门，这里推荐一个大佬博客-这篇文章讲WeakMap讲的很好。" class="headerlink" title="最近在项目中用到了Set，顺便复习了一下Set的基本API，因为Map和Set很多地方是相通的，所以顺便把Map也带上，本文只介绍基本API，这两个对象在我在项目中用的很少，至于用它们实现私有方法和存储DOM的引用推荐去看阮一峰的ES6入门，这里推荐一个大佬博客,这篇文章讲WeakMap讲的很好。"></a>最近在项目中用到了Set，顺便复习了一下Set的基本API，因为Map和Set很多地方是相通的，所以顺便把Map也带上，本文只介绍基本API，这两个对象在我在项目中用的很少，至于用它们实现私有方法和存储DOM的引用推荐去看阮一峰的ES6入门，这里推荐一个<a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2021/08/js-weakmap-es6/">大佬博客</a>,这篇文章讲WeakMap讲的很好。</h3><hr>
<h3 id="1-Map"><a href="#1-Map" class="headerlink" title="1.Map"></a>1.Map</h3><h5 id="Map是一种新的集合类型-与Object类型相似，它为js带来了真正的键-x2F-值存储机制，够保将-任意类型-的值以存键-x2F-值对的形式按顺序保存。"><a href="#Map是一种新的集合类型-与Object类型相似，它为js带来了真正的键-x2F-值存储机制，够保将-任意类型-的值以存键-x2F-值对的形式按顺序保存。" class="headerlink" title="Map是一种新的集合类型,与Object类型相似，它为js带来了真正的键&#x2F;值存储机制，够保将 任意类型 的值以存键&#x2F;值对的形式按顺序保存。"></a>Map是一种新的集合类型,与Object类型相似，它为js带来了真正的键&#x2F;值存储机制，够保将 <font color="green">任意类型</font> 的值以存键&#x2F;值对的形式按顺序保存。</h5><h5 id="在Map中键值是否相等采用的是类似于严格相等-x3D-x3D-x3D-x3D-x3D-方式来判断，但值得注意的是，在Map中认为NaN与NaN是相等的，尽管实际上NaN-x3D-x3D-NaN。"><a href="#在Map中键值是否相等采用的是类似于严格相等-x3D-x3D-x3D-x3D-x3D-方式来判断，但值得注意的是，在Map中认为NaN与NaN是相等的，尽管实际上NaN-x3D-x3D-NaN。" class="headerlink" title="在Map中键值是否相等采用的是类似于严格相等(&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;)方式来判断，但值得注意的是，在Map中认为NaN与NaN是相等的，尽管实际上NaN !&#x3D;&#x3D; NaN。"></a>在Map中键值是否相等采用的是类似于严格相等(&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;)方式来判断，但值得注意的是，在Map中认为NaN与NaN是相等的，尽管实际上NaN !&#x3D;&#x3D; NaN。</h5><h4 id="Map与Object的差异，以下表格内容来自此处"><a href="#Map与Object的差异，以下表格内容来自此处" class="headerlink" title="Map与Object的差异，以下表格内容来自此处"></a>Map与Object的差异，以下表格内容来自<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map">此处</a></h4><hr>
<table>
<thead>
<tr>
<th></th>
<th>Map</th>
<th>Object</th>
</tr>
</thead>
<tbody><tr>
<td>键的类型</td>
<td>可以是任意值，包括函数、对象或任意基本类型</td>
<td>必须是一个 String 或是 Symbol类型</td>
</tr>
<tr>
<td>键的顺序</td>
<td>Map 中的 key 是有序的。因此，当迭代的时候，一个 Map 对象以插入的顺序返回键值</td>
<td>虽然 Object 的键目前是有序的，但并不总是这样，而且这个顺序是复杂的。因此，最好不要依赖属性的顺序。</td>
</tr>
<tr>
<td>意外的键</td>
<td>Map 默认情况不包含任何键。只包含显式插入的键。</td>
<td>一个 Object 有一个原型, 原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</td>
</tr>
<tr>
<td>集合大小</td>
<td>可以通过size属性直接获取</td>
<td>Object 的键值对个数只能手动计算.</td>
</tr>
<tr>
<td>迭代</td>
<td>Map 是 可迭代的 的，所以可以直接被迭代</td>
<td>Object 不能直接迭代</td>
</tr>
<tr>
<td>性能</td>
<td>在频繁增删键值对的场景下表现更好。</td>
<td>在频繁添加和删除键值对的场景下未作出优化。</td>
</tr>
<tr>
<td>序列化和解析</td>
<td>没有元素的序列化和解析的支持。</td>
<td>原生的由 Object 到 JSON 的序列化支持，使用 JSON.stringify()</td>
</tr>
</tbody></table>
<hr>
<h5 id="创建Map集合映射"><a href="#创建Map集合映射" class="headerlink" title="创建Map集合映射"></a>创建Map集合映射</h5><h6 id="在初始化时，传入一个可迭代的对象，并且包含键值对的数组，数组的第一个值是键，第二个值是值，这个可迭代的数组对象每一组键值对都会按顺序添加到新映射中。"><a href="#在初始化时，传入一个可迭代的对象，并且包含键值对的数组，数组的第一个值是键，第二个值是值，这个可迭代的数组对象每一组键值对都会按顺序添加到新映射中。" class="headerlink" title="在初始化时，传入一个可迭代的对象，并且包含键值对的数组，数组的第一个值是键，第二个值是值，这个可迭代的数组对象每一组键值对都会按顺序添加到新映射中。"></a>在初始化时，传入一个可迭代的对象，并且包含键值对的数组，数组的第一个值是键，第二个值是值，这个可迭代的数组对象每一组键值对都会按顺序添加到新映射中。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const Map1 = new Map([[&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]])</span><br><span class="line">console.log(Map1); //Map(2) &#123;&#x27;a&#x27; =&gt; 1, &#x27;b&#x27; =&gt; 2&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Map的api"><a href="#Map的api" class="headerlink" title="Map的api"></a>Map的api</h4><ul>
<li>Map.prototype.set(key,value)</li>
</ul>
<h6 id="Map的set-方法接收一个键值对-如果该键以存在，则更新该键的值，若不存在，则在Map对象的最后添加一个新的键值对映射，返回一个映射实例，因此可以多个set-链式添加。"><a href="#Map的set-方法接收一个键值对-如果该键以存在，则更新该键的值，若不存在，则在Map对象的最后添加一个新的键值对映射，返回一个映射实例，因此可以多个set-链式添加。" class="headerlink" title="Map的set()方法接收一个键值对,如果该键以存在，则更新该键的值，若不存在，则在Map对象的最后添加一个新的键值对映射，返回一个映射实例，因此可以多个set()链式添加。"></a>Map的set()方法接收一个键值对,如果该键以存在，则更新该键的值，若不存在，则在Map对象的最后添加一个新的键值对映射，返回一个映射实例，因此可以多个set()链式添加。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map1.set(&#x27;key1&#x27;, &#x27;value1&#x27;).set(&#x27;key2&#x27;, &#x27;value2&#x27;)</span><br><span class="line">console.log(Map1)  //Map(4) &#123;&#x27;a&#x27; =&gt; 1, &#x27;b&#x27; =&gt; 2, &#x27;key1&#x27; =&gt; &#x27;value1&#x27;, &#x27;key2&#x27; =&gt; &#x27;value2&#x27;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Map.prototype.has(key)</li>
</ul>
<h6 id="Map的has-方法接收一个键名-传入要查询的键，返回一个boolean值-，存在返回true，不存在返回false-用于查询Map集合中是否存在要查询的映射。"><a href="#Map的has-方法接收一个键名-传入要查询的键，返回一个boolean值-，存在返回true，不存在返回false-用于查询Map集合中是否存在要查询的映射。" class="headerlink" title="Map的has()方法接收一个键名,传入要查询的键，返回一个boolean值 ，存在返回true，不存在返回false,用于查询Map集合中是否存在要查询的映射。"></a>Map的has()方法接收一个键名,传入要查询的键，返回一个boolean值 ，存在返回true，不存在返回false,用于查询Map集合中是否存在要查询的映射。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Map1.has(&#x27;a&#x27;));  //true</span><br><span class="line">console.log(Map1.has(&#x27;c&#x27;));  //false</span><br></pre></td></tr></table></figure>
<ul>
<li>Map.prototype.get(key)</li>
</ul>
<h6 id="Map的get-方法接收一个键名-传入要查询的键，若集合中存在该建，则返回改建所映射的值，否则返回undefine-用于查询Map集合中是否存在要查询的映射和获取要查询的映射。"><a href="#Map的get-方法接收一个键名-传入要查询的键，若集合中存在该建，则返回改建所映射的值，否则返回undefine-用于查询Map集合中是否存在要查询的映射和获取要查询的映射。" class="headerlink" title="Map的get()方法接收一个键名,传入要查询的键，若集合中存在该建，则返回改建所映射的值，否则返回undefine,用于查询Map集合中是否存在要查询的映射和获取要查询的映射。"></a>Map的get()方法接收一个键名,传入要查询的键，若集合中存在该建，则返回改建所映射的值，否则返回undefine,用于查询Map集合中是否存在要查询的映射和获取要查询的映射。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Map1.get(&#x27;a&#x27;)); // 1</span><br><span class="line">console.log(Map1.get(&#x27;c&#x27;)); // undefined</span><br></pre></td></tr></table></figure>
<ul>
<li>Map.prototype.size</li>
</ul>
<h6 id="Map的size属性用于获取该集合的大小，返回一个Number类型的值"><a href="#Map的size属性用于获取该集合的大小，返回一个Number类型的值" class="headerlink" title="Map的size属性用于获取该集合的大小，返回一个Number类型的值"></a>Map的size属性用于获取该集合的大小，返回一个Number类型的值</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Map1.size); //4</span><br></pre></td></tr></table></figure>
<ul>
<li>Map.prototype.delete(key)</li>
</ul>
<h6 id="Map的delete-方法传入要删除的键，返回值是一个boolean值，如果Map中存在要删除的键，返回true，并表示删除成功，不存在要删除的键，则返回false，表示删除失败。"><a href="#Map的delete-方法传入要删除的键，返回值是一个boolean值，如果Map中存在要删除的键，返回true，并表示删除成功，不存在要删除的键，则返回false，表示删除失败。" class="headerlink" title="Map的delete()方法传入要删除的键，返回值是一个boolean值，如果Map中存在要删除的键，返回true，并表示删除成功，不存在要删除的键，则返回false，表示删除失败。"></a>Map的delete()方法传入要删除的键，返回值是一个boolean值，如果Map中存在要删除的键，返回true，并表示删除成功，不存在要删除的键，则返回false，表示删除失败。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Map1.delete(&#x27;c&#x27;));    //false</span><br><span class="line">console.log(Map1.delete(&#x27;a&#x27;));    //true</span><br><span class="line">console.log(Map1);  // &#123;&#x27;b&#x27; =&gt; 2, &#x27;key1&#x27; =&gt; &#x27;value1&#x27;, &#x27;key2&#x27; =&gt; &#x27;value2&#x27;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Map.prototype.clear()</li>
</ul>
<h6 id="Map的clear-方法没有参数，没有返回值，调用此方法可以清空Map中所有的键值对"><a href="#Map的clear-方法没有参数，没有返回值，调用此方法可以清空Map中所有的键值对" class="headerlink" title="Map的clear()方法没有参数，没有返回值，调用此方法可以清空Map中所有的键值对"></a>Map的clear()方法没有参数，没有返回值，调用此方法可以清空Map中所有的键值对</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map1.clear()</span><br><span class="line">console.log(Map1)  //Map(0) &#123;size: 0&#125;</span><br></pre></td></tr></table></figure>
<h5 id="注意-：当引用类型作为Map的键或者值的话，我们修改引用的键或值，Map中的映射关系不会改变"><a href="#注意-：当引用类型作为Map的键或者值的话，我们修改引用的键或值，Map中的映射关系不会改变" class="headerlink" title="**注意**：当引用类型作为Map的键或者值的话，我们修改引用的键或值，Map中的映射关系不会改变,"></a>**<font color="red">注意</font>**：当引用类型作为Map的键或者值的话，我们修改引用的键或值，Map中的映射关系不会改变,</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const Map2 = new Map()</span><br><span class="line">const key1Obj = &#123; key1: &#x27;key1&#x27; &#125;</span><br><span class="line">const value1Obj = &#123; value1: &#x27;value1&#x27; &#125;</span><br><span class="line">const keyArr = [&#x27;key1&#x27;]</span><br><span class="line">const ValueArr = [&#x27;value1&#x27;]</span><br><span class="line">Map2.set(key1Obj, value1Obj).set(keyArr, ValueArr)</span><br><span class="line">console.log(Map2);  // &#123;&#123;key1: &quot;key1&quot;&#125; =&gt; &#123;value1: &#x27;value1&#x27;&#125;, [&#x27;key1&#x27;]=&gt; [&#x27;value1&#x27;]&#125;</span><br><span class="line">key1Obj.key2 = &#x27;key2&#x27;</span><br><span class="line">ValueArr.push(&#x27;value2&#x27;)</span><br><span class="line">console.log(Map2); // &#123;&#123;key1: &quot;key1&quot;,key2:&quot;key2&quot;&#125; =&gt; &#123;value1: &#x27;value1&#x27;&#125;, [&#x27;key1&#x27;]=&gt; [&#x27;value1&#x27;,&#x27;value2&#x27;]&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Map的迭代方式"><a href="#Map的迭代方式" class="headerlink" title="Map的迭代方式"></a>Map的迭代方式</h4><h6 id="Map映射实例可以提供一个迭代器（Iterator）能以插入顺序生成-key-value-形式的数组，因此Map是可以遍历的。可以通过-entries-方法（或者-Symbol-iterator-属性）取得这个迭代器。"><a href="#Map映射实例可以提供一个迭代器（Iterator）能以插入顺序生成-key-value-形式的数组，因此Map是可以遍历的。可以通过-entries-方法（或者-Symbol-iterator-属性）取得这个迭代器。" class="headerlink" title="Map映射实例可以提供一个迭代器（Iterator）能以插入顺序生成[key, value]形式的数组，因此Map是可以遍历的。可以通过 entries()方法（或者 Symbol.iterator 属性）取得这个迭代器。"></a>Map映射实例可以提供一个迭代器（Iterator）能以插入顺序生成[key, value]形式的数组，因此Map是可以遍历的。可以通过 entries()方法（或者 Symbol.iterator 属性）取得这个迭代器。</h6><h6 id="Map-prototype-entries-x3D-x3D-x3D-Map-prototype-iterator"><a href="#Map-prototype-entries-x3D-x3D-x3D-Map-prototype-iterator" class="headerlink" title="Map.prototype.entries() &#x3D;&#x3D;&#x3D; Map.prototype@@iterator"></a>Map.prototype.entries() &#x3D;&#x3D;&#x3D; Map.prototype<a href="">@@iterator</a></h6><ul>
<li>for… of <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Map3 = new Map([[&#x27;key1&#x27;, &#x27;value1&#x27;], [&#x27;key2&#x27;, &#x27;value2&#x27;], [&#x27;key3&#x27;, &#x27;value3&#x27;]])</span><br><span class="line"></span><br><span class="line">for (let el of Map3.entries()) &#123;</span><br><span class="line">  console.log(el);  // [&#x27;key1&#x27;, &#x27;value1&#x27;]  [&#x27;key2&#x27;, &#x27;value2&#x27;]  [&#x27;key2&#x27;, &#x27;value2&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">for (let el of Map3[Symbol.iterator]()) &#123;</span><br><span class="line">  console.log(el);  // [&#x27;key1&#x27;, &#x27;value1&#x27;]  [&#x27;key2&#x27;, &#x27;value2&#x27;]  [&#x27;key2&#x27;, &#x27;value2&#x27;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="Map-prototype-forEach-callback-value-key-map-thisArg"><a href="#Map-prototype-forEach-callback-value-key-map-thisArg" class="headerlink" title="Map.prototype.forEach(callback(value,key,map),thisArg)"></a>Map.prototype.forEach(callback(value,key,map),thisArg)</h6><ul>
<li>Map.forEach()接受两个参数，第一个参数是一个回调函数，该回调函数接收三个可选值，第一个值value是每个迭代的值，第一个值key是每个迭代的键，第三个值map是要迭代的Map对象。第二个参数thisArg用于指定回调函数中this的值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map3.forEach((value, key) =&gt; &#123;</span><br><span class="line">   console.log(key);       //key1 ，key2，key3</span><br><span class="line">   console.log(value);    //value1 ，value2 ，value3</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="如果只想遍历Map的值或键，可以调用values-或keys-方法，这两个方法分别返回以插入顺序生成值或键的迭代器"><a href="#如果只想遍历Map的值或键，可以调用values-或keys-方法，这两个方法分别返回以插入顺序生成值或键的迭代器" class="headerlink" title="如果只想遍历Map的值或键，可以调用values()或keys()方法，这两个方法分别返回以插入顺序生成值或键的迭代器"></a>如果只想遍历Map的值或键，可以调用values()或keys()方法，这两个方法分别返回以插入顺序生成值或键的迭代器</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (let key of Map3.keys()) &#123;</span><br><span class="line">  console.log(key);  //kye1 key2 key3</span><br><span class="line">&#125;</span><br><span class="line">for (let key of Map3.values()) &#123;</span><br><span class="line">  console.log(key);  //value1 value2 value3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注意-：如果迭代的键或者值不是引用类型，那么在迭代过程中是不可修改的，如果是引用类型的值或者键，修改后映射关系不会改变"><a href="#注意-：如果迭代的键或者值不是引用类型，那么在迭代过程中是不可修改的，如果是引用类型的值或者键，修改后映射关系不会改变" class="headerlink" title="**注意**：如果迭代的键或者值不是引用类型，那么在迭代过程中是不可修改的，如果是引用类型的值或者键，修改后映射关系不会改变"></a>**<font color="red">注意</font>**：如果迭代的键或者值不是引用类型，那么在迭代过程中是不可修改的，如果是引用类型的值或者键，修改后映射关系不会改变</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> const Map4 = new Map([[&#x27;key1&#x27;, &#x27;value1&#x27;]])</span><br><span class="line"> for (let key of Map4.keys()) &#123;</span><br><span class="line">   key = &#x27;newKey&#x27;</span><br><span class="line">   console.log(Map4.get(&#x27;newKey&#x27;));  //undefined</span><br><span class="line">   console.log(Map4.get(&#x27;key1&#x27;));  //value1  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">const keyObj = &#123; a: &#x27;1&#x27; &#125;</span><br><span class="line">const valueObj = &#123; value: &#x27;val&#x27; &#125;</span><br><span class="line">const Map5 = new Map([</span><br><span class="line">  [keyObj, valueObj]</span><br><span class="line">])</span><br><span class="line">for (let key of Map5.keys()) &#123;</span><br><span class="line">  key.a = &#x27;2&#x27;</span><br><span class="line">  key.b = &#x27;3&#x27;</span><br><span class="line">  console.log(key);  //&#123;a:&#x27;2&#x27;,b:&#x27;3&#x27; &#125;</span><br><span class="line">  console.log(Map5.get(keyObj));  //&#123; value: &#x27;val&#x27; &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Map5);  // &#123;a:&#x27;2&#x27;,b:&#x27;3&#x27; &#125; =&gt; &#123; value: &#x27;val&#x27; &#125;</span><br><span class="line">for (let value of Map5.values()) &#123;</span><br><span class="line">  value.value = &#x27;2&#x27;</span><br><span class="line">  value.newVal = &#x27;newVal&#x27;</span><br><span class="line">  console.log(Map5.get(keyObj));  //&#123;value: &#x27;2&#x27;, newVal: &#x27;newVal&#x27;&#125;  修改成功</span><br><span class="line">&#125;</span><br><span class="line">console.log(Map5);  //&#123;a: &#x27;2&#x27;, b: &#x27;3&#x27;&#125; =&gt;&#123;value: &#x27;2&#x27;, newVal: &#x27;newVal&#x27;&#125;  修改成功</span><br></pre></td></tr></table></figure>
<h3 id="2-WeakMap"><a href="#2-WeakMap" class="headerlink" title="2.WeakMap"></a>2.WeakMap</h3><h6 id="WeakMap是Map的“兄弟”类型，其-API-也是-Map-的子集，WeakMap对象是一组键-x2F-值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。"><a href="#WeakMap是Map的“兄弟”类型，其-API-也是-Map-的子集，WeakMap对象是一组键-x2F-值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。" class="headerlink" title="WeakMap是Map的“兄弟”类型，其 API 也是 Map 的子集，WeakMap对象是一组键&#x2F;值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。"></a>WeakMap是Map的“兄弟”类型，其 API 也是 Map 的子集，WeakMap对象是一组键&#x2F;值对的集合，其中的键是弱引用的。<font color= "green">其键必须是对象，而值可以是任意的</font>。</h6><h4 id="WeakMap的API"><a href="#WeakMap的API" class="headerlink" title="WeakMap的API"></a>WeakMap的API</h4><ul>
<li>WeakMap.prototype.set(key,value)</li>
</ul>
<h6 id="WeakMap的ste-方法与Map的set-方法一样，接收一组key，value映射，用于设置-x2F-更新WeakMap对象，其中，key只能是对象类型"><a href="#WeakMap的ste-方法与Map的set-方法一样，接收一组key，value映射，用于设置-x2F-更新WeakMap对象，其中，key只能是对象类型" class="headerlink" title="WeakMap的ste()方法与Map的set()方法一样，接收一组key，value映射，用于设置&#x2F;更新WeakMap对象，其中，key只能是对象类型"></a>WeakMap的ste()方法与Map的set()方法一样，接收一组key，value映射，用于设置&#x2F;更新WeakMap对象，其中，key只能是对象类型</h6><ul>
<li>WeakMap.prototype.has(key)</li>
</ul>
<h6 id="WeakMap的has-方法与Map的has-方法一样，接收一个要查询的key，返回一个Boolean值，true表示要查询的映射存在，false表示要查询的映射不存在"><a href="#WeakMap的has-方法与Map的has-方法一样，接收一个要查询的key，返回一个Boolean值，true表示要查询的映射存在，false表示要查询的映射不存在" class="headerlink" title="WeakMap的has()方法与Map的has()方法一样，接收一个要查询的key，返回一个Boolean值，true表示要查询的映射存在，false表示要查询的映射不存在"></a>WeakMap的has()方法与Map的has()方法一样，接收一个要查询的key，返回一个Boolean值，true表示要查询的映射存在，false表示要查询的映射不存在</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const WMap1 = new WeakMap()</span><br><span class="line">const key1 = &#123;&#125;</span><br><span class="line">const key2 = &#123;&#125;</span><br><span class="line">WMap1.set(key1, &#x27;value1&#x27;)</span><br><span class="line">console.log(WMap1.has(key1));  //true</span><br><span class="line">console.log(WMap1.has(key2));  //false</span><br></pre></td></tr></table></figure>
<ul>
<li>WeakMap.prototype.get(key)</li>
</ul>
<h6 id="WeakMap的get-方法接收一个要获取的key，返回对应的值，如果要回去的映射不存在，则返回undefined"><a href="#WeakMap的get-方法接收一个要获取的key，返回对应的值，如果要回去的映射不存在，则返回undefined" class="headerlink" title="WeakMap的get()方法接收一个要获取的key，返回对应的值，如果要回去的映射不存在，则返回undefined"></a>WeakMap的get()方法接收一个要获取的key，返回对应的值，如果要回去的映射不存在，则返回undefined</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(WMap1.get(key1));  //value1</span><br><span class="line">console.log(WMap1.get(key2));  //undefined</span><br></pre></td></tr></table></figure>
<ul>
<li>WeakMap.prototype.delete(key)</li>
</ul>
<h6 id="WeakMap的delete-方法与Map的delete-方法一样，接收一个要删除的key，要删除的映射存在时返回true，并表示删除成功，要删除的映射不存在则返回false"><a href="#WeakMap的delete-方法与Map的delete-方法一样，接收一个要删除的key，要删除的映射存在时返回true，并表示删除成功，要删除的映射不存在则返回false" class="headerlink" title="WeakMap的delete()方法与Map的delete()方法一样，接收一个要删除的key，要删除的映射存在时返回true，并表示删除成功，要删除的映射不存在则返回false"></a>WeakMap的delete()方法与Map的delete()方法一样，接收一个要删除的key，要删除的映射存在时返回true，并表示删除成功，要删除的映射不存在则返回false</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(WMap1.delete(key1));  //true 删除成功</span><br><span class="line">console.log(WMap1.delete(key));  //false 因为WMap1中已经不存在key1，所以返回false</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-Set"><a href="#3-Set" class="headerlink" title="3.Set"></a>3.Set</h3><h5 id="Set和Map很像，都是ECMAScript6新增的一种新的集合类型，大多数API和行为都是共有的，-Set最大的特点是Set对象允可以存储任何类型唯一值，无论是原始值或者是对象引用，并且会自动去重，使集合里面的值具有唯一性-，用来去重很方便。"><a href="#Set和Map很像，都是ECMAScript6新增的一种新的集合类型，大多数API和行为都是共有的，-Set最大的特点是Set对象允可以存储任何类型唯一值，无论是原始值或者是对象引用，并且会自动去重，使集合里面的值具有唯一性-，用来去重很方便。" class="headerlink" title="Set和Map很像，都是ECMAScript6新增的一种新的集合类型，大多数API和行为都是共有的，**Set最大的特点是Set对象允可以存储任何类型唯一值，无论是原始值或者是对象引用，并且会自动去重，使集合里面的值具有唯一性**，用来去重很方便。"></a>Set和Map很像，都是ECMAScript6新增的一种新的集合类型，大多数API和行为都是共有的，**<font  color="green">Set最大的特点是Set对象允可以存储任何类型唯一值，无论是原始值或者是对象引用，并且会自动去重，使集合里面的值具有唯一性</font>**，用来去重很方便。</h5><h5 id="创建Set对象-在Set在判断对象子项是否相等是采用的是严格相等，特别注意的是，在Set集合中，NaN被判断为相等"><a href="#创建Set对象-在Set在判断对象子项是否相等是采用的是严格相等，特别注意的是，在Set集合中，NaN被判断为相等" class="headerlink" title="创建Set对象,在Set在判断对象子项是否相等是采用的是严格相等，特别注意的是，在Set集合中，NaN被判断为相等"></a>创建Set对象,在Set在判断对象子项是否相等是采用的是严格相等，特别注意的是，在Set集合中，NaN被判断为相等</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const set1 = new Set([&#x27;1&#x27;, &#x27;2&#x27;, 2, &#x27;3&#x27;, &#x27;3&#x27;, 2])</span><br><span class="line">console.log(set1);//Set(4) &#123;&#x27;1&#x27;, &#x27;2&#x27;, 2, &#x27;3&#x27;&#125;  </span><br><span class="line">const set2 = new Set([null, undefined, null, undefined,NaN,NaN])</span><br><span class="line">console.log(set2);  //Set(3) &#123;null, undefined,NaN&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Set的API"><a href="#Set的API" class="headerlink" title="Set的API"></a>Set的API</h4><ul>
<li>Set.prototype.add(value)</li>
</ul>
<h6 id="Set的add-接受一个值，并返回集合的实例，因此可以链式调用"><a href="#Set的add-接受一个值，并返回集合的实例，因此可以链式调用" class="headerlink" title="Set的add()接受一个值，并返回集合的实例，因此可以链式调用"></a>Set的add()接受一个值，并返回集合的实例，因此可以链式调用</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const set3 = new Set()</span><br><span class="line">set3.add(1);</span><br><span class="line">set3.add(2).add(3)</span><br><span class="line">console.log(set3); //Set(3) &#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Set.prototype.has(value)</li>
</ul>
<h6 id="Set的has-方法用于查询是否有某个元素-返回值是一个boolean值，如果存在返回true，不存在则返回false"><a href="#Set的has-方法用于查询是否有某个元素-返回值是一个boolean值，如果存在返回true，不存在则返回false" class="headerlink" title="Set的has()方法用于查询是否有某个元素 返回值是一个boolean值，如果存在返回true，不存在则返回false"></a>Set的has()方法用于查询是否有某个元素 返回值是一个boolean值，如果存在返回true，不存在则返回false</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(set3.has(3)); // true</span><br><span class="line">console.log(set3.has(4)); //false</span><br></pre></td></tr></table></figure>
<ul>
<li>Set.prototype.size</li>
</ul>
<h6 id="Set的size属性返回Set对象的大小"><a href="#Set的size属性返回Set对象的大小" class="headerlink" title="Set的size属性返回Set对象的大小"></a>Set的size属性返回Set对象的大小</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(set3.size); //  3</span><br></pre></td></tr></table></figure>
<ul>
<li>Set.prototype.delete(value)</li>
</ul>
<h6 id="Set的delete-方法接收一个要删除的值，返回一个boolean值，集合中有要删除的value则返回true表示删除成功，没有则返回false表示删除失败"><a href="#Set的delete-方法接收一个要删除的值，返回一个boolean值，集合中有要删除的value则返回true表示删除成功，没有则返回false表示删除失败" class="headerlink" title="Set的delete()方法接收一个要删除的值，返回一个boolean值，集合中有要删除的value则返回true表示删除成功，没有则返回false表示删除失败"></a>Set的delete()方法接收一个要删除的值，返回一个boolean值，集合中有要删除的value则返回true表示删除成功，没有则返回false表示删除失败</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(set3.delete(4)); //false</span><br><span class="line">console.log(set3.delete(3)); //true</span><br><span class="line">console.log(set3);     //Set(2) &#123;1, 2&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Set.prototype.clear()</li>
</ul>
<h6 id="Set的clear-方法用于清空Set对象，没有返回值"><a href="#Set的clear-方法用于清空Set对象，没有返回值" class="headerlink" title="Set的clear()方法用于清空Set对象，没有返回值"></a>Set的clear()方法用于清空Set对象，没有返回值</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set3.clear()</span><br><span class="line">console.log(set3);  //Set(0) &#123;size: 0&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Set的迭代方式"><a href="#Set的迭代方式" class="headerlink" title="Set的迭代方式"></a>Set的迭代方式</h4><h5 id="Set实例也可以提供一个迭代器（Iterator），能以插入顺序生成集合内容。可以通过-values-方法及其别名方法-keys-（或者-Symbol-iterator-属性，它引用-values-）取得这个迭代器："><a href="#Set实例也可以提供一个迭代器（Iterator），能以插入顺序生成集合内容。可以通过-values-方法及其别名方法-keys-（或者-Symbol-iterator-属性，它引用-values-）取得这个迭代器：" class="headerlink" title="Set实例也可以提供一个迭代器（Iterator），能以插入顺序生成集合内容。可以通过 values()方法及其别名方法 keys()（或者 Symbol.iterator 属性，它引用 values()）取得这个迭代器："></a>Set实例也可以提供一个迭代器（Iterator），能以插入顺序生成集合内容。可以通过 values()方法及其别名方法 keys()（或者 Symbol.iterator 属性，它引用 values()）取得这个迭代器：</h5><ul>
<li>for … of<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const set4 = new Set([1, 2, 3, 4, 5, 6, 7])</span><br><span class="line"></span><br><span class="line">for (const el of set4.values()) &#123;            </span><br><span class="line">  console.log(el);  //1, 2, 3, 4, 5, 6, 7</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (const el of set4.keys()) &#123;</span><br><span class="line"> console.log(el);  //1, 2, 3, 4, 5, 6, 7</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (const el of set4[Symbol.iterator]()) &#123;</span><br><span class="line">  console.log(el);  //1, 2, 3, 4, 5, 6, 7</span><br><span class="line">&#125;</span><br><span class="line">//以上三种方式等价</span><br><span class="line">// Set对象还有个 entries()方法，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复值</span><br><span class="line">for (const el of set4.entries()) &#123;</span><br><span class="line">  console.log(el);  //[1,1], [2,2], [3,3], [4,4], [5,5],[6,6] , [7,7]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Set.prototype.forEach(callback(value,key,set),thisArg)</li>
</ul>
<h6 id="forEach-以回调函数方式遍历，接收两个参数，第一个参数是一个回调函数，该回调函数接收三个可选值，第一个值value为当前遍历的值，第二个值为当前遍历的索引，因为Set没有索引，所以，key也表示当前遍历的值，第三个元素为当前遍历的Set对象。第二个参数可以修改回调函数的this指向"><a href="#forEach-以回调函数方式遍历，接收两个参数，第一个参数是一个回调函数，该回调函数接收三个可选值，第一个值value为当前遍历的值，第二个值为当前遍历的索引，因为Set没有索引，所以，key也表示当前遍历的值，第三个元素为当前遍历的Set对象。第二个参数可以修改回调函数的this指向" class="headerlink" title="forEach()以回调函数方式遍历，接收两个参数，第一个参数是一个回调函数，该回调函数接收三个可选值，第一个值value为当前遍历的值，第二个值为当前遍历的索引，因为Set没有索引，所以，key也表示当前遍历的值，第三个元素为当前遍历的Set对象。第二个参数可以修改回调函数的this指向"></a>forEach()以回调函数方式遍历，接收两个参数，第一个参数是一个回调函数，该回调函数接收三个可选值，第一个值value为当前遍历的值，第二个值为当前遍历的索引，因为Set没有索引，所以，key也表示当前遍历的值，第三个元素为当前遍历的Set对象。第二个参数可以修改回调函数的this指向</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set4.forEach((value1, value2) =&gt; &#123;</span><br><span class="line">     console.log(&#x27;value1:&#x27; + value1, &#x27;value2:&#x27; + value2);</span><br><span class="line">   &#125;)</span><br><span class="line">//value1:1 value2:1</span><br><span class="line">//value1:2 value2:2</span><br><span class="line">//value1:3 value2:3</span><br><span class="line">//value1:4 value2:4</span><br><span class="line">//value1:5 value2:5</span><br><span class="line">//value1:6 value2:6</span><br><span class="line">//value1:7 value2:7</span><br></pre></td></tr></table></figure>
<h5 id="注意-：如果迭代值是值类型，那么在迭代过程中原来对象的值不会可修改，如果是引用类型的值则可以修改，这点和Map一样"><a href="#注意-：如果迭代值是值类型，那么在迭代过程中原来对象的值不会可修改，如果是引用类型的值则可以修改，这点和Map一样" class="headerlink" title="注意 ：如果迭代值是值类型，那么在迭代过程中原来对象的值不会可修改，如果是引用类型的值则可以修改，这点和Map一样"></a>注意 ：如果迭代值是值类型，那么在迭代过程中原来对象的值不会可修改，如果是引用类型的值则可以修改，这点和Map一样</h5><h3 id="4-WeakSet"><a href="#4-WeakSet" class="headerlink" title="4.WeakSet"></a>4.WeakSet</h3><h6 id="WeakSet是Set-的“兄弟”类型，其-API-也是-Set-的子集。WeakSet-中的“weak”（弱），描述的是-JavaScript-垃圾回收程序对待“弱集合”中值的方式。"><a href="#WeakSet是Set-的“兄弟”类型，其-API-也是-Set-的子集。WeakSet-中的“weak”（弱），描述的是-JavaScript-垃圾回收程序对待“弱集合”中值的方式。" class="headerlink" title="WeakSet是Set 的“兄弟”类型，其 API 也是 Set 的子集。WeakSet 中的“weak”（弱），描述的是 JavaScript 垃圾回收程序对待“弱集合”中值的方式。"></a>WeakSet是Set 的“兄弟”类型，其 API 也是 Set 的子集。WeakSet 中的“weak”（弱），描述的是 JavaScript 垃圾回收程序对待“弱集合”中值的方式。</h6><h5 id="WeakSet与Set的区别"><a href="#WeakSet与Set的区别" class="headerlink" title="WeakSet与Set的区别"></a>WeakSet与Set的区别</h5><h6 id="1-弱集合中的值只能是-Object-或者继承自-Object-的类型-，不能是其他类型，只要有任意类型不是Object，那么初始化就会失败"><a href="#1-弱集合中的值只能是-Object-或者继承自-Object-的类型-，不能是其他类型，只要有任意类型不是Object，那么初始化就会失败" class="headerlink" title="1.弱集合中的值只能是 Object 或者继承自 Object 的类型 ，不能是其他类型，只要有任意类型不是Object，那么初始化就会失败"></a>1.弱集合中的值只能是 Object 或者继承自 Object 的类型 ，不能是其他类型，只要有任意类型不是Object，那么初始化就会失败</h6><h6 id="2-弱集合对其元素都是弱引用，当其引用的值为空时，就会被销毁触发垃圾回收机制"><a href="#2-弱集合对其元素都是弱引用，当其引用的值为空时，就会被销毁触发垃圾回收机制" class="headerlink" title="2.弱集合对其元素都是弱引用，当其引用的值为空时，就会被销毁触发垃圾回收机制"></a>2.弱集合对其元素都是弱引用，当其引用的值为空时，就会被销毁触发垃圾回收机制</h6><h6 id="3-弱集合对其元素随时都可能被销毁，所以不可遍历"><a href="#3-弱集合对其元素随时都可能被销毁，所以不可遍历" class="headerlink" title="3.弱集合对其元素随时都可能被销毁，所以不可遍历"></a>3.弱集合对其元素随时都可能被销毁，所以不可遍历</h6><h5 id="创建-WeakSet集合-必须传入可迭代集合-null类型被认为是undefined。"><a href="#创建-WeakSet集合-必须传入可迭代集合-null类型被认为是undefined。" class="headerlink" title="创建 WeakSet集合,必须传入可迭代集合,null类型被认为是undefined。"></a>创建 WeakSet集合,必须传入可迭代集合,null类型被认为是undefined。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const WSet1 = new WeakSet([&#123; a: &#x27;1&#x27; &#125;])</span><br></pre></td></tr></table></figure>
<ul>
<li>WeakSet.prototype.add(value)</li>
</ul>
<h6 id="WeakSet的add-方法只是传入一个对象，返回一个WeakSet实例，因此-add-方法也可以链式调用，与Set相比，除了插入的值类型有限制以外，其他的都一样"><a href="#WeakSet的add-方法只是传入一个对象，返回一个WeakSet实例，因此-add-方法也可以链式调用，与Set相比，除了插入的值类型有限制以外，其他的都一样" class="headerlink" title="WeakSet的add()方法只是传入一个对象，返回一个WeakSet实例，因此 add()方法也可以链式调用，与Set相比，除了插入的值类型有限制以外，其他的都一样"></a>WeakSet的add()方法只是传入一个对象，返回一个WeakSet实例，因此 add()方法也可以链式调用，与Set相比，除了插入的值类型有限制以外，其他的都一样</h6><ul>
<li>WeakSet.prototype.has(value)</li>
</ul>
<h6 id="WeakSet的has-方法与Set的has-方法一样，传入要查询的值，返回一个Boolean值，true表示存在，false表示不存在"><a href="#WeakSet的has-方法与Set的has-方法一样，传入要查询的值，返回一个Boolean值，true表示存在，false表示不存在" class="headerlink" title="WeakSet的has()方法与Set的has()方法一样，传入要查询的值，返回一个Boolean值，true表示存在，false表示不存在"></a>WeakSet的has()方法与Set的has()方法一样，传入要查询的值，返回一个Boolean值，true表示存在，false表示不存在</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const WSet2 = new WeakSet()</span><br><span class="line">const value1 = &#123;name:&#x27;张三&#x27;&#125;</span><br><span class="line">const value2 = &#123;name:&#x27;李四&#x27;&#125;</span><br><span class="line">WSet2.add(value1 )</span><br><span class="line">WSet2.has(value1 )//true</span><br><span class="line">WSet2.has(value2) //false</span><br></pre></td></tr></table></figure>
<ul>
<li>WeakSet.prototype.delete(value)</li>
</ul>
<h6 id="WeakSet的delete-方法与Set的delete-方法一样，传入要删除的值，返回一个Boolean值，true表示要删除的值存在，并成功删除，false表示要删除的值不存在"><a href="#WeakSet的delete-方法与Set的delete-方法一样，传入要删除的值，返回一个Boolean值，true表示要删除的值存在，并成功删除，false表示要删除的值不存在" class="headerlink" title="WeakSet的delete()方法与Set的delete()方法一样，传入要删除的值，返回一个Boolean值，true表示要删除的值存在，并成功删除，false表示要删除的值不存在"></a>WeakSet的delete()方法与Set的delete()方法一样，传入要删除的值，返回一个Boolean值，true表示要删除的值存在，并成功删除，false表示要删除的值不存在</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WSet2.delete(value1 )//true   // 删除成功</span><br><span class="line">WSet2.delete(value1) //false  //因为已经删除，所以对象在不存在，再次删除失败</span><br></pre></td></tr></table></figure>


    </div>
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2022 - 2022 Blog
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @yangtao
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        
<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>
<script>
    var clientID = "", clientSecret = "";
    
    const gitalk = new Gitalk({
        clientID: clientID,
        clientSecret: clientSecret,
        repo: "",
        owner: "",
        admin: [""],
        language: "zh-CN",
        id: location.pathname,
        distractionFreeMode: false,
        
    })
    gitalk.render("gitalk-container")
</script>


    </body>
</html>